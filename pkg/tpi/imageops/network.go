package imageops

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/davidroman0O/turingpi/pkg/tpi/platform"
)

// ApplyNetworkConfig implements ImageOpsAdapter.ApplyNetworkConfig
func (a *imageOpsAdapter) ApplyNetworkConfig(mountDir string, hostname string, ipCIDR string, gateway string, dnsServers []string) error {
	// For non-Linux platforms, use Docker
	if !platform.IsLinux() && a.isDockerInitialized() {
		fmt.Println("Using Docker for network configuration...")

		// Set hostname
		hostnameCmd := fmt.Sprintf("echo '%s' > %s/etc/hostname", hostname, mountDir)
		_, err := a.executeDockerCommand(hostnameCmd)
		if err != nil {
			return fmt.Errorf("Docker hostname config failed: %w", err)
		}

		// Update /etc/hosts
		hostsContent := fmt.Sprintf("127.0.0.1\tlocalhost\n127.0.1.1\t%s\n\n", hostname)
		hostsCmd := fmt.Sprintf("echo '%s' > %s/etc/hosts", hostsContent, mountDir)
		_, err = a.executeDockerCommand(hostsCmd)
		if err != nil {
			return fmt.Errorf("Docker hosts file config failed: %w", err)
		}

		// Check if image uses Netplan
		checkNetplanCmd := fmt.Sprintf("[ -d %s/etc/netplan ] && echo 'netplan' || echo 'interfaces'", mountDir)
		netplanCheckOutput, err := a.executeDockerCommand(checkNetplanCmd)
		if err != nil {
			return fmt.Errorf("Docker netplan check failed: %w", err)
		}

		usesNetplan := strings.TrimSpace(netplanCheckOutput) == "netplan"

		if usesNetplan {
			// Apply netplan config
			fmt.Println("Applying Netplan configuration in Docker...")

			dnsAddrs := strings.Join(dnsServers, ", ")
			netplanYaml := fmt.Sprintf(`# Generated by Turing Pi CLI
network:
  version: 2
  ethernets:
    eth0:
      dhcp4: no
      addresses: [%s]
      gateway4: %s
      nameservers:
        addresses: [%s]
`, ipCIDR, gateway, dnsAddrs)

			netplanCmd := fmt.Sprintf("mkdir -p %s/etc/netplan && echo '%s' > %s/etc/netplan/01-netcfg.yaml", mountDir, netplanYaml, mountDir)
			_, err = a.executeDockerCommand(netplanCmd)
			if err != nil {
				return fmt.Errorf("Docker netplan config failed: %w", err)
			}
		} else {
			// Apply interfaces config
			fmt.Println("Applying traditional network interfaces configuration in Docker...")

			// Extract IP and network bits
			parts := strings.Split(ipCIDR, "/")
			if len(parts) != 2 {
				return fmt.Errorf("invalid IP CIDR format: %s", ipCIDR)
			}
			ipAddr := parts[0]
			networkBits := parts[1]

			// Calculate netmask
			var netmask string
			switch networkBits {
			case "24":
				netmask = "255.255.255.0"
			case "16":
				netmask = "255.255.0.0"
			case "8":
				netmask = "255.0.0.0"
			default:
				return fmt.Errorf("unsupported network bits: %s", networkBits)
			}

			dnsLine := "dns-nameservers " + strings.Join(dnsServers, " ")
			interfacesContent := fmt.Sprintf(`# Generated by Turing Pi CLI
# The loopback network interface
auto lo
iface lo inet loopback

# The primary network interface
auto eth0
iface eth0 inet static
    address %s
    netmask %s
    gateway %s
    %s
`, ipAddr, netmask, gateway, dnsLine)

			interfacesCmd := fmt.Sprintf("mkdir -p %s/etc/network && echo '%s' > %s/etc/network/interfaces", mountDir, interfacesContent, mountDir)
			_, err = a.executeDockerCommand(interfacesCmd)
			if err != nil {
				return fmt.Errorf("Docker interfaces config failed: %w", err)
			}
		}

		fmt.Println("Docker network configuration completed")
		return nil
	}

	// Native Linux approach
	// Set hostname
	hostnameFile := filepath.Join(mountDir, "etc/hostname")
	if err := writeToFileAsRoot(hostnameFile, []byte(hostname+"\n"), 0644); err != nil {
		return fmt.Errorf("failed to write hostname file: %w", err)
	}

	// Update /etc/hosts file
	hostsFile := filepath.Join(mountDir, "etc/hosts")
	hostsContent := fmt.Sprintf("127.0.0.1\tlocalhost\n127.0.1.1\t%s\n\n", hostname)
	if err := writeToFileAsRoot(hostsFile, []byte(hostsContent), 0644); err != nil {
		return fmt.Errorf("failed to update hosts file: %w", err)
	}

	// Check if image uses Netplan (Ubuntu/newer Debian) or traditional interfaces
	netplanDir := filepath.Join(mountDir, "etc/netplan")
	usesNetplan := false
	if _, err := os.Stat(netplanDir); err == nil {
		usesNetplan = true
	}

	if usesNetplan {
		// Image uses Netplan
		return internalApplyNetplanConfig(mountDir, ipCIDR, gateway, dnsServers)
	} else {
		// Fall back to traditional network interfaces config (Debian)
		return internalApplyInterfacesConfig(mountDir, ipCIDR, gateway, dnsServers)
	}
}

// internalApplyNetplanConfig creates Netplan configuration files
func internalApplyNetplanConfig(mountDir string, ipCIDR string, gateway string, dnsServers []string) error {
	netplanDir := filepath.Join(mountDir, "etc/netplan")

	// Create Netplan directory if it doesn't exist
	if err := os.MkdirAll(netplanDir, 0755); err != nil {
		return fmt.Errorf("failed to create netplan directory: %w", err)
	}

	// Get the list of current netplan files
	files, err := os.ReadDir(netplanDir)
	if err != nil {
		return fmt.Errorf("failed to read netplan directory: %w", err)
	}

	// Build netplan config
	dnsAddrs := strings.Join(dnsServers, ", ")
	netplanYaml := fmt.Sprintf(`# Generated by Turing Pi CLI
network:
  version: 2
  ethernets:
    eth0:
      dhcp4: no
      addresses: [%s]
      gateway4: %s
      nameservers:
        addresses: [%s]
`, ipCIDR, gateway, dnsAddrs)

	// Either use an existing file or create a new one
	var configPath string
	if len(files) > 0 {
		configPath = filepath.Join(netplanDir, files[0].Name())
	} else {
		configPath = filepath.Join(netplanDir, "01-netcfg.yaml")
	}

	// Write netplan config
	if err := writeToFileAsRoot(configPath, []byte(netplanYaml), 0644); err != nil {
		return fmt.Errorf("failed to write netplan config: %w", err)
	}

	return nil
}

// internalApplyInterfacesConfig creates traditional network interfaces configuration
func internalApplyInterfacesConfig(mountDir string, ipCIDR string, gateway string, dnsServers []string) error {
	interfacesFile := filepath.Join(mountDir, "etc/network/interfaces")

	// Extract IP and network bits
	parts := strings.Split(ipCIDR, "/")
	if len(parts) != 2 {
		return fmt.Errorf("invalid IP CIDR format: %s", ipCIDR)
	}
	ipAddr := parts[0]
	networkBits := parts[1]

	// Calculate netmask (simplistic for common masks)
	var netmask string
	switch networkBits {
	case "24":
		netmask = "255.255.255.0"
	case "16":
		netmask = "255.255.0.0"
	case "8":
		netmask = "255.0.0.0"
	default:
		return fmt.Errorf("unsupported network bits: %s", networkBits)
	}

	// Build interfaces config
	dnsLine := "dns-nameservers " + strings.Join(dnsServers, " ")
	interfacesContent := fmt.Sprintf(`# Generated by Turing Pi CLI
# The loopback network interface
auto lo
iface lo inet loopback

# The primary network interface
auto eth0
iface eth0 inet static
    address %s
    netmask %s
    gateway %s
    %s
`, ipAddr, netmask, gateway, dnsLine)

	// Write interfaces config
	if err := writeToFileAsRoot(interfacesFile, []byte(interfacesContent), 0644); err != nil {
		return fmt.Errorf("failed to write interfaces file: %w", err)
	}

	return nil
}
