package operations

import (
	"context"
	"fmt"
	"strings"
)

// NetworkOperations provides network operations that can be executed
// either directly on a Linux host or inside a container on non-Linux systems
type NetworkOperations struct {
	executor CommandExecutor
	fs       *FilesystemOperations
}

// NewNetworkOperations creates a new NetworkOperations instance
func NewNetworkOperations(executor CommandExecutor) *NetworkOperations {
	return &NetworkOperations{
		executor: executor,
		fs:       NewFilesystemOperations(executor),
	}
}

// ApplyNetworkConfig applies network configuration to the mounted system
func (n *NetworkOperations) ApplyNetworkConfig(ctx context.Context, mountDir, hostname, ipCIDR, gateway string, dnsServers []string) error {
	// Set hostname
	if err := n.fs.WriteFile(mountDir, "etc/hostname", []byte(hostname+"\n"), 0644); err != nil {
		return fmt.Errorf("failed to write hostname file: %w", err)
	}

	// Update /etc/hosts file
	hostsContent := fmt.Sprintf("127.0.0.1\tlocalhost\n127.0.1.1\t%s\n\n", hostname)
	if err := n.fs.WriteFile(mountDir, "etc/hosts", []byte(hostsContent), 0644); err != nil {
		return fmt.Errorf("failed to update hosts file: %w", err)
	}

	// Check if image uses Netplan (Ubuntu/newer Debian) or traditional interfaces
	usesNetplan := n.fs.FileExists(mountDir, "etc/netplan")

	if usesNetplan {
		return n.configureNetplan(mountDir, ipCIDR, gateway, dnsServers)
	} else {
		return n.configureInterfaces(mountDir, ipCIDR, gateway, dnsServers)
	}
}

// configureNetplan creates Netplan configuration for Ubuntu/newer Debian
func (n *NetworkOperations) configureNetplan(mountDir, ipCIDR, gateway string, dnsServers []string) error {
	// Create Netplan directory if it doesn't exist
	if err := n.fs.MakeDirectory(mountDir, "etc/netplan", 0755); err != nil {
		return fmt.Errorf("failed to create netplan directory: %w", err)
	}

	// Build netplan config
	dnsAddrs := strings.Join(dnsServers, ", ")
	netplanYaml := fmt.Sprintf(`# Generated by Turing Pi Tools
network:
  version: 2
  ethernets:
    eth0:
      dhcp4: no
      addresses: [%s]
      gateway4: %s
      nameservers:
        addresses: [%s]
`, ipCIDR, gateway, dnsAddrs)

	// Write netplan config
	if err := n.fs.WriteFile(mountDir, "etc/netplan/01-netcfg.yaml", []byte(netplanYaml), 0644); err != nil {
		return fmt.Errorf("failed to write netplan config: %w", err)
	}

	return nil
}

// configureInterfaces creates traditional network interfaces configuration for Debian
func (n *NetworkOperations) configureInterfaces(mountDir, ipCIDR, gateway string, dnsServers []string) error {
	// Extract IP and network bits
	parts := strings.Split(ipCIDR, "/")
	if len(parts) != 2 {
		return fmt.Errorf("invalid IP CIDR format: %s", ipCIDR)
	}
	ipAddr := parts[0]
	networkBits := parts[1]

	// Calculate netmask (simplistic for common masks)
	var netmask string
	switch networkBits {
	case "24":
		netmask = "255.255.255.0"
	case "16":
		netmask = "255.255.0.0"
	case "8":
		netmask = "255.0.0.0"
	default:
		return fmt.Errorf("unsupported network bits: %s", networkBits)
	}

	// Build interfaces config
	dnsLine := "dns-nameservers " + strings.Join(dnsServers, " ")
	interfacesContent := fmt.Sprintf(`# Generated by Turing Pi Tools
# The loopback network interface
auto lo
iface lo inet loopback

# The primary network interface
auto eth0
iface eth0 inet static
    address %s
    netmask %s
    gateway %s
    %s
`, ipAddr, netmask, gateway, dnsLine)

	// Ensure network directory exists
	if err := n.fs.MakeDirectory(mountDir, "etc/network", 0755); err != nil {
		return fmt.Errorf("failed to create network directory: %w", err)
	}

	// Write interfaces config
	if err := n.fs.WriteFile(mountDir, "etc/network/interfaces", []byte(interfacesContent), 0644); err != nil {
		return fmt.Errorf("failed to write interfaces file: %w", err)
	}

	return nil
}
